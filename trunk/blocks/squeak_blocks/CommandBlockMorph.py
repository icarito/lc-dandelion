'From MIT Squeak 0.9.4 (June 1, 2003) [No updates present.] on 30 April 2008 at 1:47:34 pm'!BlockMorph subclass: #CommandBlockMorph	instanceVariableNames: 'commandSpec argMorphs titleMorph receiver selector isReporter isTimed wantsName wantsPossession '	classVariableNames: ''	poolDictionaries: ''	category: 'Scratch-Blocks'!!CommandBlockMorph commentStamp: 'jm 5/10/2004 19:25' prior: 0!I represent a command or reporter. I have a label and may also have one or more arguments. The label text, number of arguments, and ordering of arguments and keywords are defined by my commandSpec string. This string consists of a sequence of keywords interspersed with argument specifications that indicate where the arguments appear. Here are some possible argument specifications:	%b	- boolean	%c	- color	%C	- color (chosen with eyedropper, not palette)	%m	- morph reference	%n	- number	%s	- stringExamples:	%b and %b	%m's color %C sees %C	repeat %n times!!CommandBlockMorph methodsFor: 'initialization' stamp: 'jm 10/22/2007 09:15'!initialize	super initialize.	commandSpec _ ''.	argMorphs _ OrderedCollection new.	receiver _ nil.	selector _ nil.	isTimed _ false.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 7/21/2003 01:45'!args	"Answer my arguments evaluated."	^ (argMorphs collect: [:m | m evaluate]) asArray! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 8/24/2003 17:05'!color: aColor	super color: aColor.	self layoutChanged.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 11/20/2002 09:16'!commandSpec	^ commandSpec! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 4/1/2005 10:28'!commandSpec: aString	"Set my command spec string. See my class comment."	"CommandBlockMorph new commandSpec: 'forward %n'"	"So that we don't do more work than we have to.  MethodCallBlockMorph step method calls this all the time, so we want to be careful about actually doing a relayout."	commandSpec = aString ifTrue: [^ self].	commandSpec _ aString.	self addLabel.	self addCommandIcons.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 6/15/2004 10:41'!defaultArgs: defaultValues	"Set the default values of my arguments from the given list."	1 to: (defaultValues size min: argMorphs size) do: [:i |		(argMorphs at: i) defaultValue: (defaultValues at: i)].! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 1/21/2007 11:43'!helpScreenName	"Answer the name of the help screen for this block, or nil if no help is available."	selector isInfix ifTrue: [		'+' = selector ifTrue: [^ 'minus'].		'-' = selector ifTrue: [^ 'minus'].		'*' = selector ifTrue: [^ 'minus'].		'/' = selector ifTrue: [^ 'minus'].		'<' = selector ifTrue: [^ 'lessThan'].		'=' = selector ifTrue: [^ 'equals'].		'>' = selector ifTrue: [^ 'greaterThan'].		'&' = selector ifTrue: [^ 'and'].		'|' = selector ifTrue: [^ 'or'].		'\\' = selector ifTrue: [^ 'mod'].		^ nil].	"answer the selector with colons mapped to underscores"	^ selector asString collect: [:ch | ch = $: ifTrue: [$_] ifFalse: [ch]]! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 4/15/2007 20:01'!isForever	^ (selector = #doForever) | (selector = #doForeverIf)! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 4/15/2007 19:59'!isStop	^ (selector = #doReturn) | (selector = #stopAll)! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 12/10/2003 20:58'!isTimed	^ isTimed! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'DaveF 7/10/2003 17:41'!isTimed: aBoolean	"Indicates that this block's evaluate method will be called repeatedly throughout some time interval."	isTimed _ aBoolean.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 6/22/2003 21:50'!receiver	^ receiver! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 7/7/2004 00:09'!receiver: anObject	"Set my receiver object."	receiver _ anObject.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 7/2/2003 11:47'!selector	^ selector! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 8/3/2003 23:52'!selector: aSymbol	selector _ aSymbol.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 11/30/2007 12:21'!selectorAndArg	"Answer an array containing my selector and argument (if any)."	| args |	args _ self args.	^ Array with: selector with: (args size = 0 ifTrue: [nil] ifFalse: [args first])! !!CommandBlockMorph methodsFor: 'evaluation' stamp: 'DaveF 7/9/2003 18:59'!argumentAt: index	"Returns the argument morph at the given index."	^argMorphs at: index.! !!CommandBlockMorph methodsFor: 'evaluation' stamp: 'jm 12/10/2003 18:41'!argumentCount	"Returns the number of arguments to this command block."	^ argMorphs size! !!CommandBlockMorph methodsFor: 'evaluation' stamp: 'jm 7/19/2006 11:06'!evaluate	^ self evaluateWithArgs: self args! !!CommandBlockMorph methodsFor: 'evaluation' stamp: 'jm 8/18/2006 18:39'!evaluateWithArgs: args	"Evalue this block with the given argument list."	"special case for math and boolean infix operators"	selector isInfix ifTrue: [^ args first perform: selector with: args second].	"special case for unary operators"	(#(abs not rounded sqrt truncated) includes: selector) ifTrue: [^ args first perform: selector].	^ receiver perform: selector withArguments: args asArray! !!CommandBlockMorph methodsFor: 'menus' stamp: 'jm 11/8/2007 13:48'!rightButtonMenu	| menu sFrame choice spec |	menu _ CustomMenu new.	menu add: 'help' action: #presentHelpScreen.	(owner isKindOf: ScratchBlockPaletteMorph) ifFalse: [		menu addLine.		(#(+ - * / \\) includes: selector) ifTrue: [			#(+ - * / mod) with: #(+ - * / \\) do: [:s :op | menu add: s action: op]].		(#(< = >) includes: selector) ifTrue: [			#(< = >) do: [:op | menu add: op action: op]].		(#(& |) includes: selector) ifTrue: [			#(and or) with: #(& |) do: [:s :op | menu add: s action: op]].		menu addLine.		menu add: 'duplicate' action: #duplicate.		(self owner isKindOf: BlockMorph) ifFalse: [  "can't yet delete a blocks inside a script"			menu add: 'delete' action: #delete]].	sFrame _ self ownerThatIsA: ScratchFrameMorph.	(sFrame notNil and: [#(sensor: sensorPressed:) includes: selector]) ifTrue: [		menu addLine.		menu add: 'show ScratchBoard watcher' action: #showSensorBoard].	DebugMenu ifTrue: [		menu addLine.		menu add: 'show tuples' action: #showTuples].		(choice _ menu localize; startUp) ifNil: [^ self].	(#(presentHelpScreen duplicate delete) includes: choice) ifTrue: [^ self perform: choice].	choice = #showSensorBoard ifTrue: [sFrame showSensorBoard. ^ self].	choice = #showTuples ifTrue: [^ self showTuples].	"change operator"	spec _ '%n ', choice, ' %n'.	'\\' = choice	ifTrue: [spec _ '%n mod %n'].	'&' = choice	ifTrue: [spec _ '%b and %b'].	'|' = choice	ifTrue: [spec _ '%b or %b'].	self commandSpec: spec.	self selector: choice.! !!CommandBlockMorph methodsFor: 'processes' stamp: 'jm 11/28/2006 20:08'!start	| stage |	self stop.	self receiver ifNil: [^ self].	scratchProc ifNotNil: [^ self].  "this stack is already running"	(stage _ self receiver ownerThatIsA: ScratchStageMorph) ifNil: [^ self].	scratchProc _ stage startProcessForStatements: self blockSequence.	self changed.! !!CommandBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:54'!fieldsVersion	^ 1! !!CommandBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:01'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		commandSpec		argMorphs		titleMorph		receiver		selector		isReporter		isTimed		wantsName		wantsPossession	) from: anObjStream.! !!CommandBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:01'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		commandSpec		argMorphs		titleMorph		receiver		selector		isReporter		isTimed		wantsName		wantsPossession	) on: anObjStream.! !!CommandBlockMorph methodsFor: 'stack/tuple conversion' stamp: 'jm 9/1/2006 12:54'!asBlockTuple	"Answer a tuple (Array) describing this block and its arguments."	| blockTuple arg |	blockTuple _ Array new: argMorphs size + 1.	blockTuple at: 1 put: selector.	1 to: argMorphs size do: [:i |		arg _ argMorphs at: i.		(arg isKindOf: ArgMorph) | (arg isKindOf: EventTitleMorph)			ifTrue: [blockTuple at: i + 1 put: arg evaluate]			ifFalse: [blockTuple at: i + 1 put: arg asBlockTuple]].	^ blockTuple! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 4/1/2005 10:42'!addCommandIcons	"Add additional icons to certain blocks. Do nothing if this isn't one of those blocks."	| f m |	#turnLeft: = selector ifTrue: [		f _ ScratchFrameMorph scratchSkin at: #turnCCW ifAbsent: [^ self].		m _ self firstSubmorph delete.		self addMorphFront: (ImageMorph new form: f).		self addMorphFront: m].	#turnRight: = selector ifTrue: [		f _ ScratchFrameMorph scratchSkin at: #turnCW ifAbsent: [^ self].		m _ self firstSubmorph delete.		self addMorphFront: (ImageMorph new form: f).		self addMorphFront: m].	#stopAll = selector ifTrue: [		f _ ScratchFrameMorph scratchSkin at: #stopSign ifAbsent: [^ self].		self addMorphBack: (ImageMorph new form: f)].! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 4/5/2007 20:03'!addLabel	"Add a label for my command and arguments. This is the method that really creates the whole block."	"Details: We remove all the pieces of this block, and then reassemble them, being careful not to destroy any argument morphs that we might still want to use. This is helpful if someone adds/removes parameters from a hat block."	| tokens args nextArgIndex m next |	commandSpec ifNil: [^ self].	"we make sure not to remove the next block."	next _ self nextBlock.	self removeAllMorphsIn: (self submorphs reject: [:t | t = next]).	tokens _ self parseCommandSpec.	args _ tokens select: [:s | self isArgSpec: s].	"remove any excess arg morphs from the list."	[argMorphs size > args size] whileTrue: [		m _ argMorphs last.		argMorphs remove: m.		"if the argument we're throwing out is anything complicated, we'd like to keep it around in the world."		(m isKindOf: BlockMorph) ifTrue: [m openInWorld]].	"create new arg morphs."	[argMorphs size < args size] whileTrue: [		argMorphs addLast: (self argMorphFor: (args at: argMorphs size + 1))].	nextArgIndex _ 1.	tokens do: [:s |		(self isArgSpec: s)			ifTrue:	[				m _ argMorphs at: nextArgIndex.				nextArgIndex _ nextArgIndex + 1]			ifFalse:	[				m _ self labelMorphFor: s].		self addMorphBack: m].	self isReporter ifTrue: [		m _ submorphs first.		((m isKindOf: ChoiceArgMorph) | (m isKindOf: SpriteArgMorph)) ifTrue: [  "add spacer"			self addMorphFront: (Morph new color: Color transparent; extent: 2@5)].		m _ submorphs last.		((m isKindOf: ChoiceArgMorph) | (m isKindOf: SpriteArgMorph)) ifTrue: [  "add spacer"			self addMorphBack: (Morph new color: Color transparent; extent: 2@5)]].! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 3/28/2005 17:32'!argMorphFor: specString	"Answer an argument morph for the given argument specification string. Set it's color appropriately."	| m |	m _ self uncoloredArgMorphFor: specString.	(m isKindOf: ColorArgMorph)		ifTrue: [m color: Color random].	^ m! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 5/26/2005 17:05'!argMorphToReplace: aMorph	"Answer a new argument morph to be used to replace the given morph. Answer nil if the given morph is not one of my argMorphs."	| i argSpecs spec argM defaults |	i _ argMorphs indexOf: aMorph ifAbsent: [^ nil].	argSpecs _ self parseCommandSpec select: [:s | self isArgSpec: s].	i > argSpecs size ifTrue: [^ nil].	argM _ self argMorphFor: (argSpecs at: i).	spec _ ScriptableScratchMorph blockSpecDict at: selector ifAbsent: [^ argM].	defaults _ spec copyFrom: 4 to: spec size.	i <= defaults size ifTrue: [argM defaultValue: (defaults at: i)].	^ argM! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 9/28/2006 21:37'!canBecomeWatcher	"I determine which blocks can become watchers."	| i |	i _ selector asString findAnySubStr: #('mouse' 'key' 'touching' 'distance') startingAt: 1.	^ (self isReporter) &	   (self argumentCount <= 1) &	   ((#(not atRandom abs rounded) includes: selector) not) &	   (i > selector asString size)! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 4/15/2007 12:13'!fixBlockLayout	"Update the positions of my submorphs."	| h x minXForArgs hAdjust nextB w |	blockLayoutNeeded ifFalse: [^ self].	super fixBlockLayout.	h _ 14.  "minimum height"	self nonControlFlowSubmorphs do: [:m |		(m isKindOf: BlockMorph) ifTrue: [m fixBlockLayout].		(m isKindOf: ArgMorph) ifTrue: [m fixArgLayout].		h _ h max: m height].	((self isKindOf: CBlockMorph) or: [self isKindOf: IfElseBlockMorph])		ifTrue: [minXForArgs _ self left + PuzzleInset + PuzzleWidth + 8]		ifFalse: [minXForArgs _ self left].	h _ h + 10. hAdjust _ 4.	self isReporter ifTrue: [h _ h - 2. hAdjust _ 2].	self isStop ifTrue: [h _ h - 5. hAdjust _ 0].	x _ self left + 5.	self nonControlFlowSubmorphs do: [:m |		(m isKindOf: StringMorph)			ifTrue: [m color: self labelColor]			ifFalse: [x _ x max: minXForArgs].		m position: x@(self top + (((h - hAdjust) - m height) // 2)).		x _ x + m width + 4].	w _ (x - self left) max: 37.	((self isKindOf: CBlockMorph) or:	 [self isKindOf: IfElseBlockMorph])		ifTrue: [w _ w max: 71].	self extent: w @ h.	(nextB _ self nextBlock) ifNotNil: [		(self isKindOf: CBlockMorph) ifFalse: [			nextB position: self left@(self bottom - 4)].		nextB fixBlockLayout].! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 11/20/2002 09:35'!isArgSpec: aString	"Answer true if the given string is an argument specification."	^ (aString size = 2) and: [aString first = $%]! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 6/20/2007 19:10'!labelColor	"Answer a label color, either black or white, that maximizes the contrast with my color."	^ LabelColor"old:	^ self color luminance > 0.8		ifTrue: [Color black]		ifFalse: [Color white]"! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 11/20/2002 10:23'!labelMorphFor: aString	^ (StringMorph contents: aString font: LabelFont)		color: self labelColor! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 8/5/2003 17:25'!mapReceiver: oldObj to: newObj	"Used in cloning an object to make blocks that refererred to the original object new refer to the new copy."	receiver == oldObj ifTrue: [receiver _ newObj].! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 8/31/2006 09:18'!nextBlock	"Answer the block following myself in the block sequence or nil if I am the last block in the sequence. Each block is a submorph of the previous block."	^ self submorphs		detect: [:m | (m isKindOf: BlockMorph) and: [(argMorphs includes: m) not]]		ifNone: [nil]! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 3/23/2005 18:02'!nextBlock: aBlock	"Add the given block as the block following me. Delete old nextBlock, if any."	self nextBlock ifNotNil: [self nextBlock delete].	self addMorph: aBlock.! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 6/21/2004 19:34'!parseCommandSpec	"Answer an array of token strings containing my keywords and argument specs."	| result len i j |	result _ OrderedCollection new.	len _ commandSpec size.	i _ 1.	[(i < len) and: [(commandSpec at: i) isSeparator]] whileTrue: [i _ i + 1].	[i <= len] whileTrue: [		j _ commandSpec indexOf: $% startingAt: i.		j > 0			ifTrue: [				j > i ifTrue: [result addLast: (commandSpec copyFrom: i to: j - 1)].				j < len					ifTrue: [result addLast: (commandSpec copyFrom: j to: j + 1)]					ifFalse: [result addLast: '%'].				i _ j + 2]			ifFalse: [				result addLast: (commandSpec copyFrom: i to: len).				i _ len + 1]].	^ result asArray collect: [:s | s withBlanksTrimmed]! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 12/10/2005 11:04'!printCodeOn: aStream indent: indent	"Append a human-readable string for this block on the given stream."	| nextB hasFinalSpace |	indent timesRepeat: [aStream nextPutAll: '    '].	nextB _ self nextBlock.	hasFinalSpace _ false.	submorphs do: [:m |		m ~~ nextB ifTrue: [			self printCodeSubmorph: m on: aStream.			hasFinalSpace _ true.			aStream space]].	hasFinalSpace ifTrue: [aStream skip: -1].	aStream cr.	self nextBlock ifNotNil: [self nextBlock printCodeOn: aStream indent: indent].! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 17:06'!replaceArgMorph: oldMorph by: newMorph	"Replace oldMorph with newMorph in my argMorphs and submorphs lists. This is done when dropping a reporter block onto one of my arguments."	argMorphs _ argMorphs collect: [:m |		m == oldMorph ifTrue: [newMorph] ifFalse: [m]].	self replaceSubmorph: oldMorph by: newMorph.	self layoutChanged.! !!CommandBlockMorph methodsFor: 'private' stamp: 'ee 11/9/2007 16:27'!uncoloredArgMorphFor: specString	"Answer an argument morph for the given argument specification string."	| code |	code _ specString at: 2.	$a = code ifTrue: [^ AttributeArgMorph new choice: 'volume'].	$b = code ifTrue: [^ BooleanArgMorph new].	$c = code ifTrue: [^ ColorArgMorph new showPalette: true].	$C = code ifTrue: [^ ColorArgMorph new showPalette: false].  "don't use palette; pick from screen"	$d = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '0'; menuSelector: #directionMenu].	$D = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '48'; menuSelector: #midiDrumMenu].	$e = code ifTrue: [^ EventTitleMorph new].	$f = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #mathFunctionNames; choice: 'sqrt'].	$g = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #graphicEffectNames; choice: 'color'].	$H = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #hookupSensorNames].	$h = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #hookupBooleanSensorNames].	$I = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '1'; menuSelector: #midiInstrumentMenu].	$k = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #keyNames; choice: 'space'].	$l = code ifTrue: [^ ChoiceOrExpressionArgMorph new getOptionsSelector: #costumeNames; choice: 'costume1'].	$m = code ifTrue: [^ SpriteArgMorph new].	$n = code ifTrue: [^ ExpressionArgMorph new numExpression: '10'].	$N = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '60'; menuSelector: #noteSelector].	$s = code ifTrue: [^ ExpressionArgMorph new stringExpression: ''].	$S = code ifTrue: [^ ChoiceOrExpressionArgMorph new getOptionsSelector: #soundNames; choice: 'pop'].	^ BorderedMorph new		extent: 22@18;		borderWidth: 1;		borderInset;		color: Color gray! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 3/15/2003 11:23'!updateReferencesUsing: aDictionary	"Update my arg morphs."	super updateReferencesUsing: aDictionary.	argMorphs _ argMorphs collect: [:m | aDictionary at: m ifAbsent: [m]].! !